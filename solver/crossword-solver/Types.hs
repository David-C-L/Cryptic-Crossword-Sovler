module Types where 

import Data.Array.IArray
import qualified Data.Map 
import qualified Data.Set as Set

type Clue = (String, Int)

type Words = [String]

type Index = (Int, Int)

type ClueText = Index

type Definition = Index

type Indicator = Index

type Pairs = [(Index, Index)]

type Triples = [(Index, Index, Index)]

type Quadruples = [(Index, Index, Index, Index)]

data Condition = AllowAnyDef | CheckDefIsValid | CheckDefMatchesText String
               deriving (Eq, Show) 

--
-- Generated by local parsing functions
--
type Parse = (Definition, Indicator, ParseTree)

-- Duplicate houses the singular version of the operand, e.g. hoop c.f. hoops
-- to aid the explanation.
--
-- The TreeId is (i, j, k) where 
--   (i, j) is the index of the clue text from which the parse was built
--   k is the index of the tree within those for index (i, j)
--

type TreeId = (Int, Int, Int)

--
-- The trees built by the parser
-- Bounds defines the lower & upper bounds of the solution length
-- for that parse.
--
-- We need two length bounds: the first assuming synonyms are
-- expanded and the second assuming only the literal text
-- reading. Both are assembled during parsing but only one is
-- used during evaluation.
--
type Bounds = (Int, Int)

type LengthBounds = (Bounds, Bounds)

type Depth = Int

type BoundedTree = (Tree, LengthBounds)

type UnindexedTree = (Depth, BoundedTree)

type ParseTree = ((TreeId, Depth), BoundedTree)

data Tree = SpareWord String String |
            Synonym ClueText |
            Hyponym Indicator ClueText |
            Abbreviation Indicator ClueText |
            Anagram Indicator ParseTree |
            AnagramInf Indicator ParseTree ParseTree |
            Odds Indicator ClueText |
            Evens Indicator ClueText |
            FirstLetters Indicator ParseTree |
            LastLetters Indicator ParseTree |
            MiddleLetters Indicator ParseTree |
            EndLetters Indicator ParseTree |
            Duplicate Indicator String ParseTree |
            Homophone Indicator ParseTree |
            Reversal Indicator ParseTree |
            Rotation Indicator ParseTree |
            Insertion Indicator String ParseTree ParseTree |
            Subtraction Indicator ParseTree ParseTree |
            Charade Indicator [ParseTree]
          deriving (Eq, Ord, Show)


data Pruner = NoPruning | LengthPruning | FullPruning
  
--
-- Anagram text is an array of letter frequencies, used to filter
-- potential solutions to anagram problems.
--
type AnagramText = Array Int Int

type Evaluator = String -> ParseTree -> SynExpansionRule -> Bool -> 
                 AnagramText -> [ResultTree]

-- The trees returned by the evaluator (the String is the solution).
-- Designed for speed. 
--
newtype ResultTree = R (String, [ResultTree])
                   deriving (Show)

-- 
-- The first item defines the length bounds of the items
-- stored in the table.
--
type SynonymTable = (Bounds, Array Int (Set.Set String, [String]))

type StemCache = Array Index Words

-- Parser cache...
-- The indexing key is (m, n), the start and end indices of the words
-- in the clue.
-- The string is the text in positions [m..n] of the clue
-- The tables contain the various synonyms of that string
-- The list contains the parse trees for text [m..n], with min and max lengths.

type ParserCache 
  = Array (Int, Int) CacheEntry

type IndicatorPredicateSet 
  = Array IndicatorTypes Bool

data IndicatorTypes
  = DefIndicator |
    DefRIndicator |
    HyponymInd |
    AbbreviationsInd |
    AnagramInd |
    AnagramInfInd |
    OddsInd |
    EvensInd |
    FirstLettersInd |
    LastLettersInd |
    MiddleLettersInd |
    EndLettersInd |
    DuplicateInd |
    HomophoneInd |
    RotationInd |
    ReversalInd |
    InsertionIndL1 |
    InsertionIndL2 |
    InsertionIndC1 |
    InsertionIndC2 |
    InsertionIndR1 |
    InsertionIndR2 |
    Around |
    Into |
    With |
    WithHas |
    Locate |
    Inject |
    Surround |
    SubtractionIndL1 |
    SubtractionIndL2 |
    SubtractionIndC1 |
    SubtractionIndC2 |
    SubtractionIndR1 |
    SubtractionIndR2 |
    CharadeIndL1 |
    CharadeIndL2 |
    CharadeIndC1 |
    CharadeIndC2 |
    CharadeIndR1 |
    CharadeIndR2
  deriving (Show, Eq, Ord, Ix, Bounded, Enum)

data CacheEntry 
  = CacheEntry {
      clueText            :: String,              -- clue text
      stemmedWords        :: [String],
      textSynonyms        :: SynonymTable,        -- text expansions, e.g. century -> c
      plainSynonyms       :: SynonymTable,        -- synonym table, e.g. big -> large
      singularSynonyms    :: SynonymTable,        -- singular synonym table, e.g. trees -> oak
      indicatorPredicates :: IndicatorPredicateSet,
      numSubtrees         :: Int,                 -- number of unique subtrees
      parseTrees          :: [ParseTree],         -- all parse trees
      parseTreeArray      :: Array Int ParseTree  -- the above trees as an array
    }
    deriving (Show)

type Solution = (Definition, Indicator, ParseTree, ResultTree)

--
-- The evaluation cache can optionally be turned on. It memoises calls to
-- evalB based on the tree index and the string being matched.
-- (i, j) is the Index
-- k is the index of the tree at index (i, j)
-- The Map maps possible strings to results. 
--
type EvalCache = (Array (Int, Int)
                        (Array Int
                               (Data.Map.Map String [ResultTree])))

-- 
-- The subtext type isn't strictly necessary but it tidies up the code for
-- subtext evaluation.
--
data SubtextType = First | Last | Middle | End 
                 deriving (Eq, Show, Enum)

--
-- The leaves of a parse tree are synonyms. Exactly how they are treated is
-- determined at run time, depending on context. The evaluation rules carry
-- the desired expansion rule, which is used when evaluating synonyms.
--
data SynExpansionRule = UseRawText | UseTextSyns | UseAllSyns | UseSingularSyns
                      deriving (Eq, Show)

